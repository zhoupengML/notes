* Emacs python
** C-c C-p
   start a python shell
** C-c C-z
   switch to python shell
** C-c C-c
   exec current py file

* Grammar
** 'str'.endswith
   #+BEGIN_EXAMPLE
   'a.jpg'.endswith('.jpg') # True
   #+END_EXAMPLE
** lambda
*** Format
    #+BEGIN_EXAMPLE
    g = lambda x : {'str' : x}

    which equal to

    def g(x):
        return {'str' : x}
    
    #+END_EXAMPLE
*** filter,map,reduce
    #+BEGIN_EXAMPLE
    >>> foo = [2, 18, 9, 22, 17, 24, 8, 12, 27]
    >>>
    >>> print filter(lambda x: x % 3 == 0, foo) or  [x for x in foo if x % 3 == 0]
       [18, 9, 24, 12, 27]

    >>> print map(lambda x: x * 2 + 10, foo) or  [x * 2 + 10 for x in foo]
       [14, 46, 28, 54, 44, 58, 26, 34, 64]

    >>> print reduce(lambda x, y: x + y, foo)
       139
    #+END_EXAMPLE
** List extend
   #+BEGIN_EXAMPLE
   a = [1]
   b = [2]
   a.extend(b)
   #+END_EXAMPLE
** __getattr__ , __setattr__
   - 我们可以通过重载__getattr__和__setattr__来拦截对成员的访问
     或者作出一些自己希望的行为
   - __getattr__ 在访问对象访问类中不存在的成员时会自动调用
     #+BEGIN_EXAMPLE
     class A():
     def __init__(self,ax,bx):
        self.a = ax
        self.b = bx
     def f(self):
        print (self.__dict__)
     def __getattr__(self,name):
        print ("__getattr__")

     a = A(1,2)
     a.f()
     a.x # __getattr__
     #+END_EXAMPLE
   - __setattr__ 方法用于在初始化对象成员的时候调用，即在设置__dict__的
     item 时就会调用__setattr__方法
     #+BEGIN_EXAMPLE
     class A():
     def __init__(self,ax,bx):
        self.a = ax
        self.b = bx
     def f(self):
        print (self.__dict__)
     def __getattr__(self,name):
        print ("__getattr__")
     def __setattr__(self,name,value):
        print ("__setattr__")
        self.__dict__[name] = value

     a = A(1,2)
     a.x # __getattr__
     a.x = 3 # __setattr__
     #+END_EXAMPLE

** @property
   [[http://eli.thegreenplace.net/2009/02/06/getters-and-setters-in-python/][ref]]
   - 我们将方法变成了属性，我们可以使用正常的点符号访问它。
     
   #+BEGIN_EXAMPLE
   class Person(object):
   
    def __init__(self, first_name, last_name):
        """Constructor"""
        self.first_name = first_name
        self.last_name = last_name
        
    @property
    def full_name(self):
        """
        Return the full name
        """
        return "%s %s" % (self.first_name, self.last_name)
   
   person = Person("Mike", "Driscoll")
   print person.full_name
   print person.first_name
   #+END_EXAMPLE

   - 但是，如果我们试图将该属性设为其他值，我们会引发一个
     AttributeError错误。改变full_name属性的唯一方法是间接这样做：   
     #+BEGIN_EXAMPLE
     person.first_name = "Dan"
     person.full_name
     'Dan Driscoll'
     #+END_EXAMPLE

   - 为 fee 属性创建一个 setter 方法
     #+BEGIN_EXAMPLE
     from decimal import Decimal

     class Fees(object):
     def __init__(self):
        """Constructor"""
        self._fee = None

     @property
     def fee(self):
        """
        The fee property - the getter
        """
        return self._fee

     @fee.setter
     def fee(self, value):
        """
        The setter of the fee property
        """
        if isinstance(value, str):
            self._fee = Decimal(value)
        elif isinstance(value, Decimal):
            self._fee = value
     f = Fees()
     f.fee = '1'
     #+END_EXAMPLE
** '{}'.format
   #+BEGIN_EXAMPLE
   resize = "{}x{}".format(resize_width, resize_height)
   '{:0>5d}'.format(idx)  :0填充,固定宽度5,整数
   '{:>18,.2f}'.format(1.0)     # :冒号+空白填充+右对齐+固定宽度18+浮点精度.2+浮点数声明f
   #+END_EXAMPLE
** ASCII
   #+BEGIN_EXAMPLE
   ord(a)
   chr(97)
   #+END_EXAMPLE
